<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hello World</title>
  <style>* {padding: 0; margin: 0}</style>
</head>
  <script src="./libs/pixi.min.js"></script>
  <script src="./libs/helper_functions.js"></script>
  <script src="./libs/dust.js"></script>
  <script src="./libs/pixi-sound.min.js"></script>
<body>
  <script type="text/javascript">
    let type = "WebGL"
    if(!PIXI.utils.isWebGLSupported()){
      type = "canvas"
    }

    PIXI.utils.sayHello(type)


PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;


//Aliases
let Application 	= PIXI.Application,
    Container 		= PIXI.Container,
    loader 				= PIXI.loader,
    resources 		= PIXI.loader.resources,
    Sprite 				= PIXI.Sprite,
    TextureCache 	= PIXI.utils.TextureCache,
    Graphics 			= PIXI.Graphics,
    Text 					= PIXI.Text,
    TextStyle 		= PIXI.TextStyle,
    Rectangle 		= PIXI.Rectangle;


//Create a Pixi Application
let app = new Application({width: 256, height: 256});


//Add the canvas that Pixi automatically created for you to the HTML document
document.body.appendChild(app.view);
app.renderer.view.style.position = "absolute";
app.renderer.view.style.display = "block";
app.renderer.autoResize = true;
app.renderer.resize(window.innerWidth, window.innerHeight);

// Load sprites and sounds 
loader
  .add("images/BlueShip.png")
  .add("images/block1.png")
  .add("images/redlaser.png")
  .add("images/star.png")
  .load(setup);

//PIXI.sound.add({ laser: 'sounds/laser1.mp3', block: 'sounds/block1.mp3' });
//PIXI.sound.add('laser', 'sounds/laser1.mp3');
const laserSnd = PIXI.sound.Sound.from('sounds/laser1.mp3');
const expSnd = PIXI.sound.Sound.from('sounds/explosion1.mp3');
expSnd.volume = 0.2;
//PIXI.sound.add('block', 'sounds/explosion1.mp3');

const nBlocks = 41;
const maxBullets = 20;
const minFramesSinceLastShot = 20;
const bulletSpeed = 20;
let lastShotFrame = 61;
let wall1 = new Array(nBlocks);
let wall2 = new Array(nBlocks);
let bullets = new Array(maxBullets);
let nextBullet = 0; // next bullet sprite to be fired 

let sHeight = window.innerHeight;
let sWidth  = window.innerWidth;


var Keys = {};
var fireKey = false;
window.onkeyup = function(e) { Keys[e.keyCode] = false; if (!e.ctrlKey) {fireKey = false}; }
window.onkeydown = function(e) { Keys[e.keyCode] = true; if (e.ctrlKey) {fireKey = true};  }

// create the fucking dust handler
let d = new Dust(PIXI);


//This `setup` function will run when the image has loaded
function setup() {



  // How high each pieace of wall will be, considering nBlocks blocks
  blockHeight = sHeight/(nBlocks-1); // 1 block less because one block will be offscreen  
  blockWidth  = blockHeight;   // blocks will be square for now

  // create walls
  populateWall(wall1, sWidth*0.75, 1);
  populateWall(wall2, sWidth*0.75+blockWidth, -1);

  // create bullets
  for (var i = 0; i<maxBullets; i++) {
    let s = new Sprite(loader.resources["images/redlaser.png"].texture); 
    let scaleFact = (blockWidth*2)/s.width; 
    s.scale.x = scaleFact; 
    s.scale.y = scaleFact;
    s.active = false;
    s.visible = false;
    bullets[i] = s;
    app.stage.addChild(bullets[i]);
  }


  //Create the ship sprite
  ship = new Sprite(loader.resources["images/BlueShip.png"].texture);
	let scaleFact = (blockHeight*3)/ship.height; 
	ship.scale.x = scaleFact; 
	ship.scale.y = scaleFact;
  ship.vx = 0;
  ship.vy = 0;
  ship.position.set(window.innerWidth / 2, window.innerHeight / 2);
  //Add the ship to the stage
  app.stage.addChild(ship);

	// kickoff game loop
  app.ticker.add(delta => gameLoop(delta));

}

// handy de-referencing for when we change game screeen/state
let state = play;

function gameLoop(delta){
  state(delta);
}

let count = 0;
function play(delta) {

  d.update();

	// react to keyboard input
	if (Keys[38]) {
		ship.vy = -5;
	}
	if (Keys[40]) {
		ship.vy = +5;
	}
	if (!Keys[40] && !Keys[38]) {
		ship.vy = 0;
	}
	if (Keys[39]) {
		ship.vx = +5;
	}
	if (Keys[37]) {
		ship.vx = -5;
	}
	if (!Keys[39] && !Keys[37]) {
		ship.vx = 0;
	}

  // check if shot fired. 
  // only shoot after a number of frames after last shot
  lastShotFrame++;
  //todo ... adjust for delta?
  if (fireKey  && lastShotFrame > minFramesSinceLastShot) {
    lastShotFrame = 0;
    fireShot();    
  }

  // move bullets
  for (var i = 0; i<maxBullets; i++) {
    let b = bullets[i]; // convenience
    if (b.visible) {
      b.x += b.vx * delta;
      b.y += b.vy * delta;
      // deactivate if exited screen 
      if (b.x > sWidth) {
        b.visible = false;
      }
      // check for collision with blocks
      for (var j = 0; j<nBlocks; j++) {
				let w = wall1[j]; //convenience;
        if (w.visible) {
          if (hitTestRectangle(b, w)) {
            b.visible = false;
            w.visible = false;
            explodeWall(w.x + w.width/2, w.y + w.height/2)
            break;
          }
        }
				w = wall2[j]; // convenience
        if (w.visible) {
          if (hitTestRectangle(b, w)) {
            b.visible = false;
            w.visible = false;
            explodeWall(w.x + w.width/2, w.y + w.height/2)
            break;
          }
        }
      } 
    }
  }

  //Move ship  
  ship.x += (ship.vx)*delta;
  ship.y += (ship.vy)*delta;
  if (ship.y < 0) {
    ship.y = 0;
  }
  if (ship.y > sHeight - ship.height) {
    ship.y = sHeight - ship.height;
  }
  if (ship.x < 0) {
    ship.x = 0;
  }


  // move walls        
  for (var i = 0; i<nBlocks; i++) {
    wall1[i].x += wall1[i].vx * delta;
    wall2[i].x += wall2[i].vx * delta;
    wall1[i].y += wall1[i].vy * delta;
    wall2[i].y += wall2[i].vy * delta;
    if (wall1[i].y > sHeight) {
      wall1[i].y = -blockHeight; // reposition offscreen at top
    }
    if (wall2[i].y < -blockHeight) {
      wall2[i].y = sHeight;// + blockHeight; // reposition offscreen at top
    }
  }

}

function explodeWall(x,y) {
    expSnd.play();
    d.create(
    x,
    y,
      () => new PIXI.Sprite(                     //Sprite function
        TextureCache["images/star.png"]
      ),
      app.stage,                                     //Container for particles
      50,                                         //Number of particles
    0.1,                                  //Gravity
    true,                                 //Random spacing
    Math.PI/2+0.5, Math.PI*1.5-0.5,               //Min/max angle
    12, 24,                               //Min/max size
    3, 7,                                 //Min/max speed
    0.005, 0.01,                          //Min/max scale speed
    0.005, 0.01,                          //Min/max alpha speed
    0.05, 0.1                             //Min/max rotation speed
    );
}


  </script>
</body>
</html>

